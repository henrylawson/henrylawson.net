---
layout: post
title:  "Playing with Real Data"
date:   2012-07-20 21:00:00
categories: software
---

Recently I was apart of a software project that was creating a replacement to a legacy application. This legacy application **contained a significant but not not outrageous amount of data**. As part of this replacement we had to migrate all of the existing data into our new data model. This task was **thoughtlessly left until the end of the project**, an iteration before the release. The reasoning for this decision was that it wasn't seen as a big overhead and that we were **testing our system with production like quantities of data**. That is, our generated data had around the same amount of records that the legacy application had for certain entities. The following issues were observed once the data was completely migrated:

<!--more-->

1.  Certain areas of the application performed terribly
2.  The legacy data did not contain various records that we expected to exist
3.  Our search re-indexing system performed worse

Now, two of the above points required a bit of re-work, _re-work that probably could of been addressed and identified much earlier in the project_. **The root cause of points one and three was that the complexity of our generated data did not match that of our production data. We didn't have the complex relationships that the "real" data had**. Our generated data was not derived from production data. It was generated by hand and then duplicated until the record count matched that of what we noted in production. I don't think there is anything wrong with that approach, it is certainly common practice and the simplest way to get a large data set to test against. **What we didn't realize was the impact that data with more complex one-to-one or one-to-many relationships would have on certain features of our system**.

The most obvious solution to this problem, which is considered an anti-pattern is to, _start using production data as soon as possible_. The reasons for why this is an anti-pattern are:

1.  Privacy and confidentiality issues.
2.  Some production databases are just too big to replicate across multiple development environments.
3.  Production data often becomes stale and people will typically want to "refresh" it on development environments. This results in the assumptions being made about the old data invalid. New assumptions about how the system under test should perform with the new data are then made. This ambiguity in assumptions leads to incorrect decisions and over optimization of perceived problem areas that go away after each refresh.
4.  The need to use production data highlights a lack of understanding or lack of desire to understand the complex structure of the data itself.

Problems one and two can be addressed by using _Production Like Data_. _Production Like Data_ is production data that has been obfuscated to ensure privacy and may also be a smaller but still meaningful subset of the production data. **_Production Like Data_ should always be used where production data is needed. However, _Production Like Data_ shouldn't be used everywhere:**

*   _Production Like Data_ should not be used for acceptance tests
*   _Production Like Data_ should only be used for exploratory, performance or upgrade testing

**Using _Production Like Data_ in acceptance tests really highlights a lack of understanding the data**, which is what problem three and four above are really about. A priority of acceptance tests should be to test the functionality with the _least amount of setup and overhead as possible_. This is to minimize the scope and complexity of what is being tested. **Relying on _Production Like Data_ violates this priority and will result in flaky difficult to manage tests**. Especially as there should not and probably won't be, any control on the state or content of the _Production Like Data_.

For the remaining three forms of testing, _Production Like Data_ is typically seen as OK. The reasoning behind this is that it is difficult to reach a sufficient level of confidence about the system without data that mimics that which exists in the wild.
